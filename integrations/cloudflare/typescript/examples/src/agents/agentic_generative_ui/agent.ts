/**
 * Agentic Generative UI Agent using Cloudflare Workers AI
 *
 * This agent demonstrates progressive state updates where the UI can render
 * structured data as it's being generated by the model.
 *
 * Example: When the agent generates a list of task steps, the frontend can
 * render each step progressively as it's streamed, creating a dynamic UI
 * experience.
 *
 * Features:
 * - STATE_SNAPSHOT events for progressive UI updates
 * - Structured output generation
 * - Real-time state synchronization with frontend
 */

import { CloudflareAgent, CLOUDFLARE_MODELS } from "@ag-ui/cloudflare";
import { Observable, Subscriber } from "rxjs";
import type { RunAgentInput, BaseEvent } from "@ag-ui/client";
import {
  EventType,
  type StateSnapshotEvent,
  type TextMessageStartEvent,
  type TextMessageContentEvent,
  type TextMessageEndEvent,
} from "@ag-ui/core";

/**
 * Agentic Generative UI Agent
 *
 * Generates task steps progressively and emits state updates so the frontend
 * can render the UI as the steps are being created.
 */
export class AgenticGenerativeUiAgent extends CloudflareAgent {
  constructor() {
    const accountId = process.env.CLOUDFLARE_ACCOUNT_ID;
    const apiToken = process.env.CLOUDFLARE_API_TOKEN;

    if (!accountId || !apiToken) {
      throw new Error(
        "Missing required environment variables: CLOUDFLARE_ACCOUNT_ID and CLOUDFLARE_API_TOKEN"
      );
    }

    super({
      accountId,
      apiToken,
      model: CLOUDFLARE_MODELS.LLAMA_3_1_8B,
      systemPrompt: `You are a helpful assistant that breaks down tasks into 5-10 clear, actionable steps. Format each step as "N. Description".`,
      streamingEnabled: true,
    });
  }

  /**
   * Override run() to add STATE_SNAPSHOT events during generation
   */
  run(input: RunAgentInput): Observable<BaseEvent> {
    return new Observable((subscriber) => {
      this.executeRunWithState(input, subscriber)
        .catch((error) => {
          console.error("AgenticGenerativeUiAgent execution error:", error);
          subscriber.error(error);
        })
        .finally(() => {
          subscriber.complete();
        });
    });
  }

  /**
   * Enhanced execution with progressive state updates
   * Parses numbered lists from the AI response and emits state snapshots
   */
  private async executeRunWithState(
    input: RunAgentInput,
    subscriber: Subscriber<BaseEvent>
  ): Promise<void> {
    const steps: Array<{ description: string; status: string }> = [];
    let accumulatedText = "";
    let messageId: string | null = null;

    // Create a custom subscriber that intercepts TEXT_MESSAGE events
    const customSubscriber = {
      next: (event: BaseEvent) => {
        // Pass through all events
        subscriber.next(event);

        // Track message ID for context
        if (event.type === EventType.TEXT_MESSAGE_START) {
          const startEvent = event as TextMessageStartEvent;
          messageId = startEvent.messageId;
        }

        // Extract steps from text content
        if (event.type === EventType.TEXT_MESSAGE_CONTENT) {
          const contentEvent = event as TextMessageContentEvent;
          const delta = contentEvent.delta || "";
          accumulatedText += delta;

          // Parse for numbered step patterns (e.g., "1. Step description")
          const stepMatches = accumulatedText.match(/^\s*\d+\.\s*(.+)$/gm);

          if (stepMatches && stepMatches.length > 0) {
            // Clear and rebuild steps array
            steps.length = 0;

            for (const match of stepMatches) {
              // Extract the description (everything after "N. ")
              const description = match.replace(/^\s*\d+\.\s*/, "").trim();
              if (description) {
                steps.push({
                  description,
                  status: "pending",
                });
              }
            }

            // Emit progressive state snapshot
            const progressSnapshot: StateSnapshotEvent = {
              type: EventType.STATE_SNAPSHOT,
              snapshot: {
                steps: [...steps],
                completed: false,
                progress: steps.length,
              },
              timestamp: Date.now(),
            };
            subscriber.next(progressSnapshot);
          }
        }

        // When message ends, emit final state
        if (event.type === EventType.TEXT_MESSAGE_END) {
          const finalSnapshot: StateSnapshotEvent = {
            type: EventType.STATE_SNAPSHOT,
            snapshot: {
              steps: [...steps],
              completed: true,
              totalSteps: steps.length,
            },
            timestamp: Date.now(),
          };
          subscriber.next(finalSnapshot);
        }
      },
      error: (error: Error) => {
        console.error("AgenticGenerativeUiAgent execution error:", {
          agent: "agentic_generative_ui",
          threadId: input.threadId,
          runId: input.runId,
          error: {
            message: error.message,
            stack: error.stack,
            name: error.name,
          },
        });
        subscriber.error(error);
      },
      complete: () => {
        // Ensure final state is emitted even if no TEXT_MESSAGE_END
        if (steps.length > 0) {
          const finalSnapshot: StateSnapshotEvent = {
            type: EventType.STATE_SNAPSHOT,
            snapshot: {
              steps: [...steps],
              completed: true,
              totalSteps: steps.length,
            },
            timestamp: Date.now(),
          };
          subscriber.next(finalSnapshot);
        }
      },
    };

    // Execute with custom subscriber
    await this.executeRun(input, customSubscriber as Subscriber<BaseEvent>);
  }
}

// Lazy singleton
let _agenticGenUiAgent: AgenticGenerativeUiAgent | null = null;

export function getAgenticGenerativeUiAgent(): AgenticGenerativeUiAgent {
  if (!_agenticGenUiAgent) {
    _agenticGenUiAgent = new AgenticGenerativeUiAgent();
  }
  return _agenticGenUiAgent;
}
