{"version":3,"sources":["../src/agent.ts","../src/session-manager.ts","../src/event-translator.ts","../src/types.ts","../src/tool-adapter.ts","../src/execution-state.ts","../src/utils/converters.ts"],"sourcesContent":["/**\n * Claude Agent: Main agent class that integrates Claude SDK with AG-UI Protocol\n */\n\nimport { Observable, Subscriber } from 'rxjs';\nimport {\n  AbstractAgent,\n  RunAgentInput,\n  EventType,\n  RunStartedEvent,\n  RunFinishedEvent,\n  RunErrorEvent,\n  StepStartedEvent,\n  StepFinishedEvent,\n} from '@ag-ui/client';\nimport type {\n  ClaudeAgentConfig,\n  ProcessedEvents,\n  ClaudeSDKClient,\n  Options,\n  SDKMessage,\n} from './types';\nimport { SessionManager } from './session-manager';\nimport { EventTranslator } from './event-translator';\nimport { ToolAdapter } from './tool-adapter';\nimport { ExecutionState, ExecutionStateManager } from './execution-state';\nimport {\n  generateRunId,\n  convertAgUiMessagesToPrompt,\n  isToolResultSubmission,\n  formatErrorMessage,\n} from './utils/converters';\n\n/**\n * ClaudeAgent integrates Claude Agent SDK with AG-UI Protocol\n */\nexport class ClaudeAgent extends AbstractAgent {\n  private sessionManager: SessionManager;\n  private executionStateManager: ExecutionStateManager;\n  private apiKey?: string;\n  private baseUrl?: string;\n  private sessionTimeout: number;\n  private enablePersistentSessions: boolean;\n  private permissionMode: 'default' | 'acceptEdits' | 'bypassPermissions' | 'plan';\n  private stderr?: (data: string) => void;\n  private verbose?: boolean;\n\n  constructor(config: ClaudeAgentConfig) {\n    super(config);\n    // SDK automatically reads ANTHROPIC_AUTH_TOKEN or ANTHROPIC_API_KEY from environment\n    // Only set these if explicitly provided in config (optional)\n    this.apiKey = config.apiKey;\n    this.baseUrl = config.baseUrl;\n    this.sessionTimeout = config.sessionTimeout || 30 * 60 * 1000; // 30 minutes\n    this.enablePersistentSessions = config.enablePersistentSessions !== false;\n    // Map legacy permission modes to new SDK values for backward compatibility\n    this.permissionMode = this.mapPermissionMode(config.permissionMode || 'bypassPermissions');\n    this.stderr = config.stderr;\n    this.verbose = config.verbose;\n    this.sessionManager = SessionManager.getInstance(this.sessionTimeout);\n    this.executionStateManager = new ExecutionStateManager();\n  }\n\n  /**\n   * Map legacy permission modes to new SDK values for backward compatibility\n   */\n  private mapPermissionMode(mode?: string): 'default' | 'acceptEdits' | 'bypassPermissions' | 'plan' {\n    const modeMap: Record<string, 'default' | 'acceptEdits' | 'bypassPermissions' | 'plan'> = {\n      'ask': 'default',\n      'auto': 'bypassPermissions',\n      'none': 'bypassPermissions',\n      'default': 'default',\n      'acceptEdits': 'acceptEdits',\n      'bypassPermissions': 'bypassPermissions',\n      'plan': 'plan',\n    };\n    return modeMap[mode || 'bypassPermissions'] || 'bypassPermissions';\n  }\n\n  /**\n   * Run the agent with the given input\n   */\n  run(input: RunAgentInput): Observable<ProcessedEvents> {\n    return new Observable((subscriber) => {\n      this.executeAgent(input, subscriber).catch((error) => {\n        subscriber.error(error);\n      });\n    });\n  }\n\n  /**\n   * Execute the agent asynchronously\n   */\n  private async executeAgent(\n    input: RunAgentInput,\n    subscriber: Subscriber<ProcessedEvents>\n  ): Promise<void> {\n    const runId = generateRunId();\n    const sessionId = input.threadId || `session_${Date.now()}`;\n\n    // Create execution state\n    const execution = this.executionStateManager.createExecution(runId, sessionId);\n\n    try {\n      // Emit run started event\n      const runStartedEvent: RunStartedEvent = {\n        type: EventType.RUN_STARTED,\n        threadId: sessionId,\n        runId,\n      };\n      subscriber.next(runStartedEvent);\n      execution.addEvent(runStartedEvent);\n\n      // Get or create session\n      const session = this.sessionManager.getSession(sessionId, 'default');\n\n      // Get unseen messages\n      const unseenMessages = this.sessionManager.getUnseenMessages(\n        sessionId,\n        input.messages || []\n      );\n\n      // Check if this is a tool result submission\n      const isToolResult = isToolResultSubmission(input.messages || []);\n\n      // Prepare tools\n      const tools = input.tools || [];\n      \n      // Prepare options for Claude SDK\n      const options = await this.prepareClaudeOptions(tools);\n\n      // Extract prompt from messages\n      const prompt = convertAgUiMessagesToPrompt(unseenMessages);\n\n      // Emit step started event\n      const stepStartedEvent: StepStartedEvent = {\n        type: EventType.STEP_STARTED,\n        stepName: `step_${runId}_1`,\n      };\n      subscriber.next(stepStartedEvent);\n      execution.addEvent(stepStartedEvent);\n\n      // Call Claude SDK\n      await this.callClaudeSDK(\n        prompt,\n        options,\n        session,\n        runId,\n        sessionId,\n        subscriber,\n        execution\n      );\n\n      // Mark messages as processed\n      this.sessionManager.markMessagesAsProcessed(sessionId, unseenMessages);\n\n      // Emit step finished event\n      const stepFinishedEvent: StepFinishedEvent = {\n        type: EventType.STEP_FINISHED,\n        stepName: `step_${runId}_1`,\n      };\n      subscriber.next(stepFinishedEvent);\n      execution.addEvent(stepFinishedEvent);\n\n      // Emit run finished event\n      const runFinishedEvent: RunFinishedEvent = {\n        type: EventType.RUN_FINISHED,\n        threadId: sessionId,\n        runId,\n      };\n      subscriber.next(runFinishedEvent);\n      execution.addEvent(runFinishedEvent);\n\n      // Complete execution\n      execution.complete();\n      subscriber.complete();\n    } catch (error: any) {\n      // Emit run error event\n      const runErrorEvent: RunErrorEvent = {\n        type: EventType.RUN_ERROR,\n        message: formatErrorMessage(error),\n      };\n      subscriber.next(runErrorEvent);\n      execution.addEvent(runErrorEvent);\n\n      // Mark execution as failed\n      execution.fail(error);\n\n      // Complete the observable\n      subscriber.complete();\n    }\n  }\n\n  /**\n   * Prepare Claude SDK options\n   * SDK automatically reads ANTHROPIC_AUTH_TOKEN or ANTHROPIC_API_KEY from environment\n   * But baseUrl needs to be explicitly passed for third-party APIs\n   */\n  private async prepareClaudeOptions(tools: any[]): Promise<Options> {\n    // Get baseUrl from config or environment\n    const baseUrl = this.baseUrl || process.env.ANTHROPIC_BASE_URL;\n    const apiKey = this.apiKey || process.env.ANTHROPIC_AUTH_TOKEN || process.env.ANTHROPIC_API_KEY;\n    \n    // Debug logging\n    console.log('[Claude Agent] Preparing SDK options:', {\n      hasApiKey: !!apiKey,\n      hasBaseUrl: !!baseUrl,\n      baseUrl: baseUrl || 'not set',\n      permissionMode: this.permissionMode,\n      hasStderr: !!this.stderr,\n      verbose: this.verbose,\n    });\n    \n    const options: Options = {\n      permissionMode: this.permissionMode,\n      // Add stderr callback for debugging - CRITICAL for error logging\n      ...(this.stderr && { stderr: this.stderr }),\n      // Add verbose flag for detailed logging\n      ...(this.verbose !== undefined && { verbose: this.verbose }),\n      env: process.env\n    };\n    \n    // Verify stderr callback is set\n    if (this.stderr) {\n      console.log('[Claude Agent] ✓ stderr callback is configured for error logging');\n    } else {\n      console.warn('[Claude Agent] ⚠️  stderr callback not configured - CLI errors may not be visible');\n    }\n\n    // Add tools if provided\n    if (tools && tools.length > 0) {\n      const mcpServer = await ToolAdapter.createMcpServerForTools(tools);\n      options.mcpServers = {\n        ag_ui_tools: mcpServer,\n      };\n\n      // Set allowed tools\n      options.allowedTools = ToolAdapter.getAllowedToolsList(tools);\n    }\n\n    return options;\n  }\n\n  /**\n   * Call Claude SDK\n   * Note: Currently only stateless mode is supported via query() function\n   */\n  private async callClaudeSDK(\n    prompt: string,\n    options: Options,\n    session: any,\n    runId: string,\n    sessionId: string,\n    subscriber: Subscriber<ProcessedEvents>,\n    execution: ExecutionState\n  ): Promise<void> {\n    const eventTranslator = new EventTranslator(runId, sessionId);\n\n    // The current @anthropic-ai/claude-agent-sdk only supports stateless mode\n    // via the query() function. We use stateless mode for both cases.\n    await this.callClaudeSDKStateless(\n      prompt,\n      options,\n      eventTranslator,\n      subscriber,\n      execution\n    );\n  }\n\n  /**\n   * Call Claude SDK in persistent session mode\n   * Note: The current SDK only supports stateless mode via query() function\n   * This method falls back to stateless mode\n   */\n  private async callClaudeSDKPersistent(\n    prompt: string,\n    options: Options,\n    session: any,\n    eventTranslator: EventTranslator,\n    subscriber: Subscriber<ProcessedEvents>,\n    execution: ExecutionState\n  ): Promise<void> {\n    // The current @anthropic-ai/claude-agent-sdk only supports stateless mode\n    // via the query() function. For persistent sessions, we use query() \n    // but maintain session state in our SessionManager\n    await this.callClaudeSDKStateless(prompt, options, eventTranslator, subscriber, execution);\n  }\n\n  /**\n   * Call Claude SDK in stateless mode\n   */\n  private async callClaudeSDKStateless(\n    prompt: string,\n    options: Options,\n    eventTranslator: EventTranslator,\n    subscriber: Subscriber<ProcessedEvents>,\n    execution: ExecutionState\n  ): Promise<void> {\n    try {\n      // Log environment variables for debugging\n      console.log('[Claude Agent] Environment check:');\n      console.log('  ANTHROPIC_API_KEY:', process.env.ANTHROPIC_API_KEY ? 'SET' : 'NOT SET');\n      console.log('  ANTHROPIC_AUTH_TOKEN:', process.env.ANTHROPIC_AUTH_TOKEN ? 'SET' : 'NOT SET');\n      console.log('  ANTHROPIC_BASE_URL:', process.env.ANTHROPIC_BASE_URL || 'NOT SET (using default)');\n      console.log('[Claude Agent] Options passed to SDK:', {\n        hasApiKey: !!options.apiKey,\n        hasBaseUrl: !!options.baseUrl,\n        permissionMode: options.permissionMode,\n        hasMcpServers: !!options.mcpServers,\n      });\n\n      // Import Claude SDK dynamically\n      const { query } = await this.importClaudeSDK();\n\n      console.log('[Claude Agent] Calling SDK query()...');\n\n      // Call query function\n      // SDK will automatically read API key from environment variables (ANTHROPIC_API_KEY or ANTHROPIC_AUTH_TOKEN)\n      // if not provided in options.apiKey\n      const queryResult = query({ prompt, options });\n\n      // Process responses\n      for await (const message of queryResult) {\n        console.log('[Claude Agent] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');\n        console.log('[Claude Agent] Received message type:', message?.type || 'unknown');\n        console.log('[Claude Agent] Full message:', JSON.stringify(message, null, 2));\n        \n        if (execution.isAborted()) {\n          console.log('[Claude Agent] Execution aborted by user');\n          break;\n        }\n\n        const events = eventTranslator.translateMessage(message);\n        console.log('[Claude Agent] Translated events count:', events.length);\n        for (const event of events) {\n          console.log('[Claude Agent] Sending event:', JSON.stringify(event, null, 2));\n          subscriber.next(event);\n          execution.addEvent(event);\n        }\n        console.log('[Claude Agent] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');\n      }\n      \n      console.log('[Claude Agent] Query completed successfully');\n    } catch (error: any) {\n      // Log detailed error information\n      console.error('[Claude Agent] ERROR Details:');\n      console.error('  Message:', error.message);\n      console.error('  Stack:', error.stack);\n      console.error('  Error object:', JSON.stringify(error, Object.getOwnPropertyNames(error), 2));\n      \n      // Handle Claude Code process errors\n      if (error.message && error.message.includes('exited with code')) {\n        throw new Error(\n          `Claude Code process failed. Please ensure:\\n` +\n          `1. Claude CLI is installed and accessible (run: claude --version)\\n` +\n          `2. ANTHROPIC_API_KEY or ANTHROPIC_AUTH_TOKEN is set correctly in environment variables\\n` +\n          `3. You have proper permissions to run Claude Code\\n` +\n          `4. If using ANTHROPIC_BASE_URL, ensure it supports Claude Code protocol\\n` +\n          `\\nOriginal error: ${error.message}\\n` +\n          `Error stack: ${error.stack || 'No stack trace'}`\n        );\n      }\n      // Handle API key errors from SDK\n      if (error.message && (error.message.includes('API key') || error.message.includes('auth'))) {\n        throw new Error(\n          `API key error: ${error.message}\\n` +\n          `Please ensure ANTHROPIC_API_KEY or ANTHROPIC_AUTH_TOKEN is set in environment variables.`\n        );\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Dynamically import Claude SDK\n   */\n  private async importClaudeSDK(): Promise<any> {\n    try {\n      return await import('@anthropic-ai/claude-agent-sdk');\n    } catch (error) {\n      throw new Error(\n        'Claude Agent SDK not found. Please install it: npm install @anthropic-ai/claude-agent-sdk'\n      );\n    }\n  }\n\n  /**\n   * Abort a running execution\n   */\n  abortExecution(runId: string): void {\n    const execution = this.executionStateManager.getExecution(runId);\n    if (execution) {\n      execution.abort();\n    }\n  }\n\n  /**\n   * Get execution state\n   */\n  getExecutionState(runId: string): ExecutionState | undefined {\n    return this.executionStateManager.getExecution(runId);\n  }\n\n  /**\n   * Get session manager (for testing)\n   */\n  getSessionManager(): SessionManager {\n    return this.sessionManager;\n  }\n\n  /**\n   * Get execution state manager (for testing)\n   */\n  getExecutionStateManager(): ExecutionStateManager {\n    return this.executionStateManager;\n  }\n\n  /**\n   * Cleanup resources\n   */\n  async cleanup(): Promise<void> {\n    // Abort all running executions\n    const runningExecutions = this.executionStateManager.getRunningExecutions();\n    for (const execution of runningExecutions) {\n      execution.abort();\n    }\n\n    // Clear all sessions\n    this.sessionManager.clearAllSessions();\n\n    // Clear all executions\n    this.executionStateManager.clearAll();\n  }\n}\n\n","/**\n * Session manager: Manages agent sessions and state\n */\n\nimport type { Message } from '@ag-ui/client';\nimport type { Session, ClaudeSDKClient } from './types';\n\nconst DEFAULT_SESSION_TIMEOUT = 30 * 60 * 1000; // 30 minutes\nconst CLEANUP_INTERVAL = 5 * 60 * 1000; // 5 minutes\n\n/**\n * SessionManager handles session lifecycle, message tracking, and state management\n * Implements singleton pattern for centralized session control\n */\nexport class SessionManager {\n  private static instance: SessionManager | null = null;\n  private sessions: Map<string, Session> = new Map();\n  private cleanupInterval: ReturnType<typeof setInterval> | null = null;\n  private sessionTimeout: number;\n\n  private constructor(sessionTimeout: number = DEFAULT_SESSION_TIMEOUT) {\n    this.sessionTimeout = sessionTimeout;\n    this.startCleanupInterval();\n  }\n\n  /**\n   * Get the singleton instance\n   */\n  static getInstance(sessionTimeout?: number): SessionManager {\n    if (!SessionManager.instance) {\n      SessionManager.instance = new SessionManager(sessionTimeout);\n    }\n    return SessionManager.instance;\n  }\n\n  /**\n   * Reset the singleton instance (useful for testing)\n   */\n  static resetInstance(): void {\n    if (SessionManager.instance) {\n      SessionManager.instance.stopCleanupInterval();\n      SessionManager.instance = null;\n    }\n  }\n\n  /**\n   * Get or create a session\n   */\n  getSession(sessionId: string, userId?: string): Session {\n    let session = this.sessions.get(sessionId);\n\n    if (!session) {\n      session = {\n        id: sessionId,\n        userId,\n        processedMessageIds: new Set<string>(),\n        state: {},\n        createdAt: Date.now(),\n        lastAccessedAt: Date.now(),\n      };\n      this.sessions.set(sessionId, session);\n    } else {\n      // Update last accessed time\n      session.lastAccessedAt = Date.now();\n    }\n\n    return session;\n  }\n\n  /**\n   * Check if a session exists\n   */\n  hasSession(sessionId: string): boolean {\n    return this.sessions.has(sessionId);\n  }\n\n  /**\n   * Delete a session\n   */\n  deleteSession(sessionId: string): boolean {\n    const session = this.sessions.get(sessionId);\n    if (session?.client) {\n      // Close the Claude SDK client if it exists\n      session.client.close().catch((error) => {\n        console.error(`Error closing Claude SDK client for session ${sessionId}:`, error);\n      });\n    }\n    return this.sessions.delete(sessionId);\n  }\n\n  /**\n   * Track a processed message\n   */\n  trackMessage(sessionId: string, messageId: string): void {\n    const session = this.sessions.get(sessionId);\n    if (session) {\n      session.processedMessageIds.add(messageId);\n      session.lastAccessedAt = Date.now();\n    }\n  }\n\n  /**\n   * Check if a message has been processed\n   */\n  isMessageProcessed(sessionId: string, messageId: string): boolean {\n    const session = this.sessions.get(sessionId);\n    return session ? session.processedMessageIds.has(messageId) : false;\n  }\n\n  /**\n   * Get unseen messages (messages not yet processed)\n   */\n  getUnseenMessages(sessionId: string, messages: Message[]): Message[] {\n    const session = this.sessions.get(sessionId);\n    if (!session) {\n      return messages;\n    }\n\n    return messages.filter((msg) => {\n      const msgId = msg.id || `${msg.role}_${msg.content}`;\n      return !session.processedMessageIds.has(msgId);\n    });\n  }\n\n  /**\n   * Mark messages as processed\n   */\n  markMessagesAsProcessed(sessionId: string, messages: Message[]): void {\n    const session = this.sessions.get(sessionId);\n    if (session) {\n      for (const msg of messages) {\n        const msgId = msg.id || `${msg.role}_${msg.content}`;\n        session.processedMessageIds.add(msgId);\n      }\n      session.lastAccessedAt = Date.now();\n    }\n  }\n\n  /**\n   * Get state value from session\n   */\n  getStateValue(sessionId: string, key: string): any {\n    const session = this.sessions.get(sessionId);\n    return session?.state[key];\n  }\n\n  /**\n   * Set state value in session\n   */\n  setStateValue(sessionId: string, key: string, value: any): void {\n    const session = this.sessions.get(sessionId);\n    if (session) {\n      session.state[key] = value;\n      session.lastAccessedAt = Date.now();\n    }\n  }\n\n  /**\n   * Remove state keys from session\n   */\n  removeStateKeys(sessionId: string, keys: string[]): void {\n    const session = this.sessions.get(sessionId);\n    if (session) {\n      for (const key of keys) {\n        delete session.state[key];\n      }\n      session.lastAccessedAt = Date.now();\n    }\n  }\n\n  /**\n   * Clear all state for a session\n   */\n  clearSessionState(sessionId: string): void {\n    const session = this.sessions.get(sessionId);\n    if (session) {\n      session.state = {};\n      session.lastAccessedAt = Date.now();\n    }\n  }\n\n  /**\n   * Set Claude SDK client for a session\n   */\n  setClient(sessionId: string, client: ClaudeSDKClient): void {\n    const session = this.sessions.get(sessionId);\n    if (session) {\n      session.client = client;\n      session.lastAccessedAt = Date.now();\n    }\n  }\n\n  /**\n   * Get Claude SDK client for a session\n   */\n  getClient(sessionId: string): ClaudeSDKClient | undefined {\n    const session = this.sessions.get(sessionId);\n    return session?.client;\n  }\n\n  /**\n   * Get total number of sessions\n   */\n  getSessionCount(): number {\n    return this.sessions.size;\n  }\n\n  /**\n   * Get number of sessions for a specific user\n   */\n  getUserSessionCount(userId: string): number {\n    let count = 0;\n    for (const session of this.sessions.values()) {\n      if (session.userId === userId) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  /**\n   * Get all session IDs\n   */\n  getAllSessionIds(): string[] {\n    return Array.from(this.sessions.keys());\n  }\n\n  /**\n   * Get all sessions for a specific user\n   */\n  getUserSessions(userId: string): Session[] {\n    const userSessions: Session[] = [];\n    for (const session of this.sessions.values()) {\n      if (session.userId === userId) {\n        userSessions.push(session);\n      }\n    }\n    return userSessions;\n  }\n\n  /**\n   * Clean up stale sessions\n   */\n  private cleanupStaleSessions(): void {\n    const now = Date.now();\n    const sessionsToDelete: string[] = [];\n\n    for (const [sessionId, session] of this.sessions.entries()) {\n      if (now - session.lastAccessedAt > this.sessionTimeout) {\n        sessionsToDelete.push(sessionId);\n      }\n    }\n\n    for (const sessionId of sessionsToDelete) {\n      this.deleteSession(sessionId);\n    }\n\n    if (sessionsToDelete.length > 0) {\n      console.log(`Cleaned up ${sessionsToDelete.length} stale sessions`);\n    }\n  }\n\n  /**\n   * Start the cleanup interval\n   */\n  private startCleanupInterval(): void {\n    if (!this.cleanupInterval) {\n      this.cleanupInterval = setInterval(() => {\n        this.cleanupStaleSessions();\n      }, CLEANUP_INTERVAL);\n\n      // Don't keep the process alive just for this interval\n      if (typeof (this.cleanupInterval as any).unref === 'function') {\n        (this.cleanupInterval as any).unref();\n      }\n    }\n  }\n\n  /**\n   * Stop the cleanup interval\n   */\n  private stopCleanupInterval(): void {\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval);\n      this.cleanupInterval = null;\n    }\n  }\n\n  /**\n   * Clear all sessions (useful for testing)\n   */\n  clearAllSessions(): void {\n    for (const sessionId of this.sessions.keys()) {\n      this.deleteSession(sessionId);\n    }\n    this.sessions.clear();\n  }\n}\n\n","/**\n * Event translator: Converts Claude SDK messages to AG-UI events\n */\n\nimport {\n  TextMessageStartEvent,\n  TextMessageContentEvent,\n  TextMessageEndEvent,\n  ToolCallStartEvent,\n  ToolCallArgsEvent,\n  ToolCallEndEvent,\n  ToolCallResultEvent,\n  EventType,\n} from '@ag-ui/client';\nimport type {\n  SDKMessage,\n  SDKAssistantMessage,\n  ContentBlock,\n  TextBlock,\n  ToolUseBlock,\n  ToolResultBlock,\n  ProcessedEvents,\n} from './types';\nimport {\n  hasContentProperty,\n  isTextBlock,\n  isToolUseBlock,\n  isToolResultBlock,\n} from './types';\n\n/**\n * EventTranslator converts Claude SDK messages to AG-UI protocol events\n * \n * NOTE: This translator only handles SDK message translation.\n * Run lifecycle events (RUN_STARTED, RUN_FINISHED, etc.) and step events\n * are handled by ClaudeAgent.\n */\nexport class EventTranslator {\n  private messageIdCounter = 0;\n  private currentMessageId: string | null = null;\n  private runId: string;\n  private threadId: string;\n\n  constructor(runId: string, threadId: string) {\n    this.runId = runId;\n    this.threadId = threadId;\n  }\n\n  /**\n   * Translate a Claude SDK message to AG-UI events\n   * NOTE: Does not emit RUN_STARTED, RUN_FINISHED, or STEP events - those are handled by ClaudeAgent\n   */\n  translateMessage(message: SDKMessage): ProcessedEvents[] {\n    const events: ProcessedEvents[] = [];\n\n    if (hasContentProperty(message)) {\n      events.push(...this.translateAssistantMessage(message as SDKAssistantMessage));\n    }\n    // Note: ResultMessage (success/error) is ignored here\n    // Run completion is handled by ClaudeAgent, not EventTranslator\n\n    return events;\n  }\n\n  /**\n   * Translate an AssistantMessage with content blocks\n   */\n  private translateAssistantMessage(message: SDKAssistantMessage): ProcessedEvents[] {\n    const events: ProcessedEvents[] = [];\n\n    // Content is in message.message.content for SDKAssistantMessage\n    const content = message.message?.content || [];\n    \n    for (const block of content) {\n      if (isTextBlock(block)) {\n        events.push(...this.translateTextBlock(block));\n      } else if (isToolUseBlock(block)) {\n        events.push(...this.translateToolUseBlock(block));\n      } else if (isToolResultBlock(block)) {\n        events.push(...this.translateToolResultBlock(block));\n      }\n    }\n\n    return events;\n  }\n\n  /**\n   * Translate a TextBlock to text message events\n   * NOTE: Step events are handled by ClaudeAgent, not here\n   */\n  private translateTextBlock(block: TextBlock): ProcessedEvents[] {\n    const events: ProcessedEvents[] = [];\n    const messageId = this.generateMessageId();\n\n    // Start event\n    events.push({\n      type: EventType.TEXT_MESSAGE_START,\n      messageId,\n      role: 'assistant',\n    });\n\n    // Content event - split text into delta chunks\n    const text = block.text;\n    if (text.length > 0) {\n      events.push({\n        type: EventType.TEXT_MESSAGE_CONTENT,\n        messageId,\n        delta: text,\n      });\n    }\n\n    // End event\n    events.push({\n      type: EventType.TEXT_MESSAGE_END,\n      messageId,\n    });\n\n    return events;\n  }\n\n  /**\n   * Translate a ToolUseBlock to tool call events\n   * NOTE: Step events are handled by ClaudeAgent, not here\n   */\n  private translateToolUseBlock(block: ToolUseBlock): ProcessedEvents[] {\n    const events: ProcessedEvents[] = [];\n    const toolCallId = block.id;\n\n    // Start event\n    events.push({\n      type: EventType.TOOL_CALL_START,\n      toolCallId,\n      toolCallName: block.name,\n    });\n\n    // Args event - send args as JSON string\n    const argsJson = JSON.stringify(block.input);\n    if (argsJson.length > 0) {\n      events.push({\n        type: EventType.TOOL_CALL_ARGS,\n        toolCallId,\n        delta: argsJson,\n      });\n    }\n\n    // End event\n    events.push({\n      type: EventType.TOOL_CALL_END,\n      toolCallId,\n    });\n\n    return events;\n  }\n\n  /**\n   * Translate a ToolResultBlock to tool call result event\n   */\n  private translateToolResultBlock(block: ToolResultBlock): ProcessedEvents[] {\n    const events: ProcessedEvents[] = [];\n\n    // Extract content as string\n    let resultContent: string;\n    if (typeof block.content === 'string') {\n      resultContent = block.content;\n    } else if (Array.isArray(block.content)) {\n      // Handle array of content blocks\n      resultContent = block.content\n        .map((item) => {\n          if (item.type === 'text') {\n            return item.text || '';\n          }\n          return JSON.stringify(item);\n        })\n        .join('\\n');\n    } else {\n      resultContent = JSON.stringify(block.content);\n    }\n\n    const messageId = this.generateMessageId();\n    events.push({\n      type: EventType.TOOL_CALL_RESULT,\n      toolCallId: block.tool_use_id,\n      messageId,\n      content: resultContent,\n      ...(block.is_error && { role: 'tool' as const }),\n    });\n\n    return events;\n  }\n\n  /**\n   * Generate a unique message ID\n   */\n  private generateMessageId(): string {\n    this.messageIdCounter++;\n    return `msg_${this.runId}_${this.messageIdCounter}`;\n  }\n\n  /**\n   * Reset the translator state for a new execution\n   */\n  reset(): void {\n    this.messageIdCounter = 0;\n    this.currentMessageId = null;\n  }\n\n  /**\n   * Get current message ID\n   */\n  getCurrentMessageId(): string | null {\n    return this.currentMessageId;\n  }\n\n  /**\n   * Set current message ID\n   */\n  setCurrentMessageId(messageId: string | null): void {\n    this.currentMessageId = messageId;\n  }\n}\n\n","/**\n * Type definitions for Claude Agent SDK integration with AG-UI Protocol\n */\n\nimport type {\n  TextMessageStartEvent,\n  TextMessageContentEvent,\n  TextMessageEndEvent,\n  ToolCallStartEvent,\n  ToolCallArgsEvent,\n  ToolCallEndEvent,\n  ToolCallResultEvent,\n  RunStartedEvent,\n  RunFinishedEvent,\n  RunErrorEvent,\n  StepStartedEvent,\n  StepFinishedEvent,\n  AgentConfig,\n  Tool,\n  Message,\n} from '@ag-ui/client';\n\n// Re-export Claude SDK types (will be imported from the actual SDK)\n// These are placeholder interfaces based on the SDK documentation\nexport interface ClaudeSDKClient {\n  query(prompt: string): Promise<void>;\n  receiveResponse(): AsyncIterableIterator<SDKMessage>;\n  close(): Promise<void>;\n}\n\nexport interface Options {\n  apiKey?: string;\n  baseUrl?: string;\n  mcpServers?: Record<string, McpSdkServerConfigWithInstance>;\n  allowedTools?: string[];\n  // Valid permission modes from Agent SDK: 'default', 'acceptEdits', 'bypassPermissions', 'plan'\n  // Legacy values 'ask', 'auto', 'none' are also supported for backward compatibility\n  permissionMode?: 'default' | 'acceptEdits' | 'bypassPermissions' | 'plan' | 'ask' | 'auto' | 'none';\n  stderr?: (data: string) => void;\n  verbose?: boolean;\n  [key: string]: any;\n}\n\nexport interface Query {\n  next(): Promise<IteratorResult<SDKMessage, void>>;\n  [Symbol.asyncIterator](): AsyncIterableIterator<SDKMessage>;\n}\n\n// SDK Message types based on documentation\nexport type SDKMessage =\n  | SDKAssistantMessage\n  | SDKUserMessage\n  | SDKSystemMessage\n  | SDKResultMessage\n  | SDKPartialAssistantMessage\n  | SDKCompactBoundaryMessage\n  | SDKPermissionDenial;\n\nexport interface SDKAssistantMessage {\n  type: 'assistant';\n  message: {\n    id?: string;\n    content: ContentBlock[];\n    [key: string]: any;\n  };\n  parent_tool_use_id?: string | null;\n  uuid?: string;\n  session_id?: string;\n}\n\nexport interface SDKUserMessage {\n  type: 'user';\n  content: string;\n  id?: string;\n}\n\nexport interface SDKSystemMessage {\n  type: 'system';\n  content: string;\n}\n\nexport interface SDKResultMessage {\n  type: 'result';\n  subtype: 'success' | 'error';\n  error?: {\n    type: string;\n    message: string;\n  };\n}\n\nexport interface SDKPartialAssistantMessage {\n  type: 'partial_assistant';\n  content: ContentBlock[];\n}\n\nexport interface SDKCompactBoundaryMessage {\n  type: 'compact_boundary';\n}\n\nexport interface SDKPermissionDenial {\n  type: 'permission_denial';\n  tool: string;\n  reason: string;\n}\n\n// Content block types\nexport type ContentBlock = TextBlock | ToolUseBlock | ToolResultBlock | ThinkingBlock;\n\nexport interface TextBlock {\n  type: 'text';\n  text: string;\n}\n\nexport interface ToolUseBlock {\n  type: 'tool_use';\n  id: string;\n  name: string;\n  input: Record<string, any>;\n}\n\nexport interface ToolResultBlock {\n  type: 'tool_result';\n  tool_use_id: string;\n  content: string | Array<{ type: string; [key: string]: any }>;\n  is_error?: boolean;\n}\n\nexport interface ThinkingBlock {\n  type: 'thinking';\n  thinking: string;\n}\n\n// Tool definition types\nexport interface SdkMcpToolDefinition<Schema = any> {\n  name: string;\n  description: string;\n  inputSchema: Schema;\n  handler: (args: any, extra?: any) => Promise<CallToolResult>;\n}\n\nexport interface CallToolResult {\n  content: Array<{\n    type: 'text' | 'image' | 'resource';\n    text?: string;\n    data?: string;\n    mimeType?: string;\n    [key: string]: any;\n  }>;\n  isError?: boolean;\n}\n\nexport interface McpSdkServerConfigWithInstance {\n  name: string;\n  version?: string;\n  tools?: Array<SdkMcpToolDefinition<any>>;\n}\n\n// AG-UI Integration types\nexport type ProcessedEvents =\n  | TextMessageStartEvent\n  | TextMessageContentEvent\n  | TextMessageEndEvent\n  | ToolCallStartEvent\n  | ToolCallArgsEvent\n  | ToolCallEndEvent\n  | ToolCallResultEvent\n  | RunStartedEvent\n  | RunFinishedEvent\n  | RunErrorEvent\n  | StepStartedEvent\n  | StepFinishedEvent;\n\n// Session management types\nexport interface Session {\n  id: string;\n  userId?: string;\n  client?: ClaudeSDKClient;\n  processedMessageIds: Set<string>;\n  state: Record<string, any>;\n  createdAt: number;\n  lastAccessedAt: number;\n}\n\n// Agent configuration\nexport interface ClaudeAgentConfig extends AgentConfig {\n  apiKey?: string;\n  baseUrl?: string;\n  sessionTimeout?: number;\n  enablePersistentSessions?: boolean;\n  // Valid permission modes from Agent SDK: 'default', 'acceptEdits', 'bypassPermissions', 'plan'\n  // Legacy values 'ask', 'auto', 'none' are mapped internally for backward compatibility\n  permissionMode?: 'default' | 'acceptEdits' | 'bypassPermissions' | 'plan' | 'ask' | 'auto' | 'none';\n  mcpServers?: Record<string, McpSdkServerConfigWithInstance>;\n  stderr?: (data: string) => void;\n  verbose?: boolean;\n}\n\n// Execution state types\nexport interface ExecutionState {\n  id: string;\n  sessionId: string;\n  isRunning: boolean;\n  startTime: number;\n  events: ProcessedEvents[];\n  error?: Error;\n}\n\n// Helper type guards\nexport function isAssistantMessage(message: SDKMessage): message is SDKAssistantMessage {\n  return message.type === 'assistant';\n}\n\nexport function isResultMessage(message: SDKMessage): message is SDKResultMessage {\n  return message.type === 'result';\n}\n\nexport function isTextBlock(block: ContentBlock): block is TextBlock {\n  return block.type === 'text';\n}\n\nexport function isToolUseBlock(block: ContentBlock): block is ToolUseBlock {\n  return block.type === 'tool_use';\n}\n\nexport function isToolResultBlock(block: ContentBlock): block is ToolResultBlock {\n  return block.type === 'tool_result';\n}\n\nexport function isThinkingBlock(block: ContentBlock): block is ThinkingBlock {\n  return block.type === 'thinking';\n}\n\nexport function hasContentProperty(message: SDKMessage): message is SDKAssistantMessage | SDKPartialAssistantMessage {\n  // For SDKAssistantMessage, content is in message.content\n  if (message.type === 'assistant') {\n    return 'message' in message && \n           message.message !== null &&\n           typeof message.message === 'object' &&\n           'content' in message.message && \n           Array.isArray((message.message as any).content);\n  }\n  // For SDKPartialAssistantMessage, content might be at top level\n  return 'content' in message && Array.isArray((message as any).content);\n}\n\n// Tool execution types\nexport interface ToolExecutionContext {\n  toolName: string;\n  toolCallId: string;\n  isClientTool: boolean;\n  isLongRunning: boolean;\n}\n\n// Message conversion types\nexport interface ConvertedMessage {\n  role: 'user' | 'assistant' | 'system';\n  content: string | Array<{ type: string; [key: string]: any }>;\n}\n\n","/**\n * Tool adapter: Converts AG-UI tools to Claude SDK format\n */\n\nimport { z } from 'zod';\nimport type { Tool } from '@ag-ui/client';\nimport type {\n  SdkMcpToolDefinition,\n  McpSdkServerConfigWithInstance,\n  CallToolResult,\n} from './types';\n\n// Extended Tool type that includes runtime properties\ntype ExtendedTool = Tool & {\n  client?: boolean;\n  handler?: (args: any) => any | Promise<any>;\n  longRunning?: boolean;\n};\n\n/**\n * ToolAdapter handles conversion of AG-UI tools to Claude SDK format\n */\nexport class ToolAdapter {\n  /**\n   * Convert AG-UI tools to Claude SDK MCP tool definitions\n   */\n  static convertAgUiToolsToSdk(tools: Tool[]): SdkMcpToolDefinition<any>[] {\n    return tools.map((tool) => this.convertSingleTool(tool as ExtendedTool));\n  }\n\n  /**\n   * Convert a single AG-UI tool to Claude SDK format\n   */\n  private static convertSingleTool(tool: ExtendedTool): SdkMcpToolDefinition<any> {\n    const zodSchema = this.convertJsonSchemaToZod(tool.parameters || {});\n\n    return {\n      name: tool.name,\n      description: tool.description || '',\n      inputSchema: zodSchema,\n      handler: async (args: any) => {\n        // For client tools, we mark them as long-running\n        // The actual execution will be handled by the client\n        if (tool.client) {\n          return {\n            content: [\n              {\n                type: 'text',\n                text: JSON.stringify({\n                  toolName: tool.name,\n                  args,\n                  isClientTool: true,\n                  isLongRunning: true,\n                }),\n              },\n            ],\n          };\n        }\n\n        // For backend tools, if there's a handler, execute it\n        if (tool.handler) {\n          try {\n            const result = await tool.handler(args);\n            return {\n              content: [\n                {\n                  type: 'text',\n                  text: typeof result === 'string' ? result : JSON.stringify(result),\n                },\n              ],\n            };\n          } catch (error: any) {\n            return {\n              content: [\n                {\n                  type: 'text',\n                  text: error.message || 'Tool execution failed',\n                },\n              ],\n              isError: true,\n            };\n          }\n        }\n\n        // Default response for tools without handlers\n        return {\n          content: [\n            {\n              type: 'text',\n              text: 'Tool executed (no handler)',\n            },\n          ],\n        };\n      },\n    };\n  }\n\n  /**\n   * Convert JSON Schema to Zod schema\n   */\n  private static convertJsonSchemaToZod(jsonSchema: any): z.ZodTypeAny {\n    if (!jsonSchema || typeof jsonSchema !== 'object') {\n      return z.object({});\n    }\n\n    const properties = jsonSchema.properties || {};\n    const required = jsonSchema.required || [];\n\n    const zodShape: Record<string, z.ZodTypeAny> = {};\n\n    for (const [key, prop] of Object.entries(properties)) {\n      const propSchema = prop as any;\n      let zodType = this.convertJsonSchemaTypeToZod(propSchema);\n\n      // Make optional if not in required array\n      if (!required.includes(key)) {\n        zodType = zodType.optional();\n      }\n\n      zodShape[key] = zodType;\n    }\n\n    return z.object(zodShape);\n  }\n\n  /**\n   * Convert a single JSON Schema type to Zod type\n   */\n  private static convertJsonSchemaTypeToZod(schema: any): z.ZodTypeAny {\n    const type = schema.type;\n\n    switch (type) {\n      case 'string':\n        if (schema.enum) {\n          return z.enum(schema.enum as [string, ...string[]]);\n        }\n        return z.string();\n\n      case 'number':\n      case 'integer':\n        let numType = type === 'integer' ? z.number().int() : z.number();\n        if (schema.minimum !== undefined) {\n          numType = numType.min(schema.minimum);\n        }\n        if (schema.maximum !== undefined) {\n          numType = numType.max(schema.maximum);\n        }\n        return numType;\n\n      case 'boolean':\n        return z.boolean();\n\n      case 'array':\n        if (schema.items) {\n          const itemType = this.convertJsonSchemaTypeToZod(schema.items);\n          return z.array(itemType);\n        }\n        return z.array(z.any());\n\n      case 'object':\n        if (schema.properties) {\n          return this.convertJsonSchemaToZod(schema);\n        }\n        return z.record(z.any());\n\n      case 'null':\n        return z.null();\n\n      default:\n        // For any other type or if type is not specified\n        return z.any();\n    }\n  }\n\n  /**\n   * Create an MCP server configuration for AG-UI tools\n   */\n  static async createMcpServerForTools(tools: Tool[]): Promise<any> {\n    const sdkTools = this.convertAgUiToolsToSdk(tools as ExtendedTool[]);\n\n    // Import createSdkMcpServer from Claude Agent SDK\n    const { createSdkMcpServer } = await import('@anthropic-ai/claude-agent-sdk');\n    \n    // Use the official SDK function to create a properly formatted MCP server\n    return createSdkMcpServer({\n      name: 'ag_ui_tools',\n      version: '1.0.0',\n      tools: sdkTools as any, // Cast to any to avoid type incompatibility\n    });\n  }\n\n  /**\n   * Extract tool calls from Claude SDK response\n   */\n  static extractToolCalls(message: any): Array<{\n    id: string;\n    name: string;\n    input: Record<string, any>;\n  }> {\n    if (!message.content || !Array.isArray(message.content)) {\n      return [];\n    }\n\n    return message.content\n      .filter((block: any) => block.type === 'tool_use')\n      .map((block: any) => ({\n        id: block.id,\n        name: block.name,\n        input: block.input,\n      }));\n  }\n\n  /**\n   * Check if a tool is a long-running client tool\n   */\n  static isClientTool(toolName: string, tools: Tool[]): boolean {\n    const tool = tools.find((t) => t.name === toolName) as ExtendedTool | undefined;\n    return tool?.client === true;\n  }\n\n  /**\n   * Check if a tool is marked as long-running\n   */\n  static isLongRunningTool(toolName: string, tools: Tool[]): boolean {\n    const tool = tools.find((t) => t.name === toolName) as ExtendedTool | undefined;\n    return tool?.client === true || tool?.longRunning === true;\n  }\n\n  /**\n   * Format tool names for Claude SDK (with MCP server prefix)\n   */\n  static formatToolNameForSdk(toolName: string, serverName: string = 'ag_ui_tools'): string {\n    return `mcp__${serverName}__${toolName}`;\n  }\n\n  /**\n   * Parse tool name from SDK format (remove MCP server prefix)\n   */\n  static parseToolNameFromSdk(sdkToolName: string): string {\n    const parts = sdkToolName.split('__');\n    if (parts.length >= 3 && parts[0] === 'mcp') {\n      return parts.slice(2).join('__');\n    }\n    return sdkToolName;\n  }\n\n  /**\n   * Get allowed tools list for SDK options\n   */\n  static getAllowedToolsList(tools: Tool[], serverName: string = 'ag_ui_tools'): string[] {\n    return tools.map((tool) => this.formatToolNameForSdk(tool.name, serverName));\n  }\n}\n\n","/**\n * Execution state: Tracks background Claude executions\n */\n\nimport type { ProcessedEvents } from './types';\n\n/**\n * ExecutionState manages the state of a Claude SDK execution\n */\nexport class ExecutionState {\n  readonly id: string;\n  readonly sessionId: string;\n  private _isRunning: boolean;\n  private _startTime: number;\n  private _endTime?: number;\n  private _events: ProcessedEvents[];\n  private _error?: Error;\n  private _abortController: AbortController;\n\n  constructor(id: string, sessionId: string) {\n    this.id = id;\n    this.sessionId = sessionId;\n    this._isRunning = true;\n    this._startTime = Date.now();\n    this._events = [];\n    this._abortController = new AbortController();\n  }\n\n  /**\n   * Check if execution is running\n   */\n  get isRunning(): boolean {\n    return this._isRunning;\n  }\n\n  /**\n   * Get start time\n   */\n  get startTime(): number {\n    return this._startTime;\n  }\n\n  /**\n   * Get end time\n   */\n  get endTime(): number | undefined {\n    return this._endTime;\n  }\n\n  /**\n   * Get duration in milliseconds\n   */\n  get duration(): number {\n    const end = this._endTime || Date.now();\n    return end - this._startTime;\n  }\n\n  /**\n   * Get all collected events\n   */\n  get events(): ProcessedEvents[] {\n    return [...this._events];\n  }\n\n  /**\n   * Get error if any\n   */\n  get error(): Error | undefined {\n    return this._error;\n  }\n\n  /**\n   * Get abort signal\n   */\n  get signal(): AbortSignal {\n    return this._abortController.signal;\n  }\n\n  /**\n   * Add an event to the execution state\n   */\n  addEvent(event: ProcessedEvents): void {\n    this._events.push(event);\n  }\n\n  /**\n   * Add multiple events\n   */\n  addEvents(events: ProcessedEvents[]): void {\n    this._events.push(...events);\n  }\n\n  /**\n   * Mark execution as completed\n   */\n  complete(): void {\n    if (this._isRunning) {\n      this._isRunning = false;\n      this._endTime = Date.now();\n    }\n  }\n\n  /**\n   * Mark execution as failed\n   */\n  fail(error: Error): void {\n    if (this._isRunning) {\n      this._isRunning = false;\n      this._endTime = Date.now();\n      this._error = error;\n    }\n  }\n\n  /**\n   * Abort the execution\n   */\n  abort(): void {\n    if (this._isRunning) {\n      this._abortController.abort();\n      this._isRunning = false;\n      this._endTime = Date.now();\n    }\n  }\n\n  /**\n   * Get execution statistics\n   */\n  getStats(): {\n    duration: number;\n    eventCount: number;\n    isRunning: boolean;\n    hasError: boolean;\n  } {\n    return {\n      duration: this.duration,\n      eventCount: this._events.length,\n      isRunning: this._isRunning,\n      hasError: !!this._error,\n    };\n  }\n\n  /**\n   * Clear events (useful for memory management)\n   */\n  clearEvents(): void {\n    this._events = [];\n  }\n\n  /**\n   * Get the last N events\n   */\n  getLastEvents(count: number): ProcessedEvents[] {\n    return this._events.slice(-count);\n  }\n\n  /**\n   * Check if execution has been aborted\n   */\n  isAborted(): boolean {\n    return this._abortController.signal.aborted;\n  }\n}\n\n/**\n * ExecutionStateManager manages multiple execution states\n */\nexport class ExecutionStateManager {\n  private executions: Map<string, ExecutionState> = new Map();\n  private readonly maxExecutions: number;\n\n  constructor(maxExecutions: number = 100) {\n    this.maxExecutions = maxExecutions;\n  }\n\n  /**\n   * Create a new execution state\n   */\n  createExecution(id: string, sessionId: string): ExecutionState {\n    const execution = new ExecutionState(id, sessionId);\n    this.executions.set(id, execution);\n\n    // Clean up old executions if we exceed the limit\n    if (this.executions.size > this.maxExecutions) {\n      this.cleanupOldExecutions();\n    }\n\n    return execution;\n  }\n\n  /**\n   * Get an execution state by ID\n   */\n  getExecution(id: string): ExecutionState | undefined {\n    return this.executions.get(id);\n  }\n\n  /**\n   * Check if an execution exists\n   */\n  hasExecution(id: string): boolean {\n    return this.executions.has(id);\n  }\n\n  /**\n   * Delete an execution state\n   */\n  deleteExecution(id: string): boolean {\n    return this.executions.delete(id);\n  }\n\n  /**\n   * Get all executions for a session\n   */\n  getSessionExecutions(sessionId: string): ExecutionState[] {\n    const executions: ExecutionState[] = [];\n    for (const execution of this.executions.values()) {\n      if (execution.sessionId === sessionId) {\n        executions.push(execution);\n      }\n    }\n    return executions;\n  }\n\n  /**\n   * Get running executions\n   */\n  getRunningExecutions(): ExecutionState[] {\n    const running: ExecutionState[] = [];\n    for (const execution of this.executions.values()) {\n      if (execution.isRunning) {\n        running.push(execution);\n      }\n    }\n    return running;\n  }\n\n  /**\n   * Get completed executions\n   */\n  getCompletedExecutions(): ExecutionState[] {\n    const completed: ExecutionState[] = [];\n    for (const execution of this.executions.values()) {\n      if (!execution.isRunning) {\n        completed.push(execution);\n      }\n    }\n    return completed;\n  }\n\n  /**\n   * Abort all running executions for a session\n   */\n  abortSessionExecutions(sessionId: string): void {\n    const sessionExecutions = this.getSessionExecutions(sessionId);\n    for (const execution of sessionExecutions) {\n      if (execution.isRunning) {\n        execution.abort();\n      }\n    }\n  }\n\n  /**\n   * Clean up old completed executions\n   */\n  private cleanupOldExecutions(): void {\n    const completed = this.getCompletedExecutions();\n    \n    // Sort by end time (oldest first)\n    completed.sort((a, b) => {\n      const aTime = a.endTime || a.startTime;\n      const bTime = b.endTime || b.startTime;\n      return aTime - bTime;\n    });\n\n    // Remove the oldest executions\n    const toRemove = Math.max(0, this.executions.size - this.maxExecutions);\n    for (let i = 0; i < toRemove && i < completed.length; i++) {\n      this.executions.delete(completed[i].id);\n    }\n  }\n\n  /**\n   * Clear all executions\n   */\n  clearAll(): void {\n    this.executions.clear();\n  }\n\n  /**\n   * Get total execution count\n   */\n  getExecutionCount(): number {\n    return this.executions.size;\n  }\n\n  /**\n   * Get execution statistics\n   */\n  getStats(): {\n    total: number;\n    running: number;\n    completed: number;\n    failed: number;\n  } {\n    let running = 0;\n    let completed = 0;\n    let failed = 0;\n\n    for (const execution of this.executions.values()) {\n      if (execution.isRunning) {\n        running++;\n      } else if (execution.error) {\n        failed++;\n      } else {\n        completed++;\n      }\n    }\n\n    return {\n      total: this.executions.size,\n      running,\n      completed,\n      failed,\n    };\n  }\n}\n\n","/**\n * Message format converters\n */\n\nimport type { Message } from '@ag-ui/client';\nimport type { ConvertedMessage } from '../types';\n\n/**\n * Convert AG-UI messages to a format suitable for Claude SDK\n */\nexport function convertAgUiMessagesToPrompt(messages: Message[]): string {\n  // For Claude SDK, we typically extract the last user message as the prompt\n  // The SDK maintains conversation history internally (in persistent mode)\n  \n  // Find the last user message\n  for (let i = messages.length - 1; i >= 0; i--) {\n    const msg = messages[i];\n    if (msg.role === 'user') {\n      return extractMessageContent(msg);\n    }\n  }\n\n  // If no user message found, return a default prompt\n  return 'Hello';\n}\n\n/**\n * Extract text content from a message\n */\nexport function extractMessageContent(message: Message): string {\n  if (typeof message.content === 'string') {\n    return message.content;\n  }\n\n  if (Array.isArray(message.content)) {\n    return message.content\n      .map((block: any) => {\n        if (typeof block === 'string') {\n          return block;\n        }\n        if (block.type === 'text') {\n          return block.text || '';\n        }\n        // For other types (image, file, etc.), we might need special handling\n        return '';\n      })\n      .filter(Boolean)\n      .join('\\n');\n  }\n\n  return String(message.content);\n}\n\n/**\n * Convert AG-UI message to Claude message format\n */\nexport function convertAgUiMessageToClaude(message: Message): ConvertedMessage {\n  const role = message.role as 'user' | 'assistant' | 'system';\n  const content = extractMessageContent(message);\n\n  return {\n    role,\n    content,\n  };\n}\n\n/**\n * Convert multiple AG-UI messages to Claude format\n */\nexport function convertAgUiMessagesToClaude(messages: Message[]): ConvertedMessage[] {\n  return messages.map(convertAgUiMessageToClaude);\n}\n\n/**\n * Check if messages contain tool results\n */\nexport function hasToolResults(messages: Message[]): boolean {\n  return messages.some((msg) => {\n    if (typeof msg.content === 'string') {\n      return false;\n    }\n    if (Array.isArray(msg.content)) {\n      return msg.content.some((block: any) => {\n        return typeof block === 'object' && block.type === 'tool_result';\n      });\n    }\n    return false;\n  });\n}\n\n/**\n * Extract tool results from messages\n */\nexport function extractToolResults(messages: Message[]): Array<{\n  toolCallId: string;\n  result: string;\n}> {\n  const results: Array<{ toolCallId: string; result: string }> = [];\n\n  for (const msg of messages) {\n    if (typeof msg.content === 'string') {\n      continue;\n    }\n\n    if (Array.isArray(msg.content)) {\n      for (const block of msg.content as any[]) {\n        if (typeof block === 'object' && block.type === 'tool_result') {\n          results.push({\n            toolCallId: (block as any).toolCallId || (block as any).tool_use_id || '',\n            result: (block as any).result || (block as any).content || '',\n          });\n        }\n      }\n    }\n  }\n\n  return results;\n}\n\n/**\n * Generate a unique run ID\n */\nexport function generateRunId(): string {\n  return `run_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n}\n\n/**\n * Generate a unique message ID\n */\nexport function generateMessageId(prefix: string = 'msg'): string {\n  return `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n}\n\n/**\n * Safely parse JSON string\n */\nexport function safeJsonParse(json: string, defaultValue: any = null): any {\n  try {\n    return JSON.parse(json);\n  } catch {\n    return defaultValue;\n  }\n}\n\n/**\n * Safely stringify JSON\n */\nexport function safeJsonStringify(obj: any, defaultValue: string = '{}'): string {\n  try {\n    return JSON.stringify(obj);\n  } catch {\n    return defaultValue;\n  }\n}\n\n/**\n * Check if a message is a tool result submission\n */\nexport function isToolResultSubmission(messages: Message[]): boolean {\n  // Check if the last message contains tool results\n  if (messages.length === 0) {\n    return false;\n  }\n\n  const lastMessage = messages[messages.length - 1];\n  return hasToolResults([lastMessage]);\n}\n\n/**\n * Format error message for display\n */\nexport function formatErrorMessage(error: any): string {\n  if (error instanceof Error) {\n    return error.message;\n  }\n  if (typeof error === 'string') {\n    return error;\n  }\n  return 'An unknown error occurred';\n}\n\n/**\n * Truncate text to a maximum length\n */\nexport function truncateText(text: string, maxLength: number = 1000): string {\n  if (text.length <= maxLength) {\n    return text;\n  }\n  return text.slice(0, maxLength) + '...';\n}\n\n/**\n * Merge consecutive text blocks\n */\nexport function mergeTextBlocks(blocks: Array<{ type: string; text?: string }>): string {\n  return blocks\n    .filter((block: any) => block.type === 'text' && block.text)\n    .map((block: any) => block.text)\n    .join('');\n}\n\n"],"mappings":"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","names":["EventType","EventType","error"]}